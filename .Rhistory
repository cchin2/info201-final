library("shiny")
# Load the `shiny` package
install.packages("shiny")
# Install and load the `ggplot2` package
# You will also want to load `dplyr`
library("ggplot2")
library("dplyr")
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
diamonds_sample <- sample_n(diamonds, 1000)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamonds_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamonds_sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
View(diamonds_sample)
# Draw the same plot as above, but color each of the points based on their
# clarity.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamonds_sample) + geom_smooth(mapping = aes(x = carat, y = price))
# Draw a plot with column geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis and `price` to the y-axis. Note that by default, column geometry
# will us the "sum" of all of the y-values, so that the chart is actually of the
# TOTAL value of all of the diamonds of that cut!
ggplot(data = diamonds_sample) +
geom_col(mapping = aes(x = cut, y = price))
# Add an aesthetic property that will _fill_ each bar geometry based on the
# `clarity` of the diamonds.
# What kind of chart do you get?
ggplot(data = diamonds_sample) +
geom_col(mapping = aes(x = cut, y = price, fill = clarity))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, color = cut), alpha = 0.3) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut), se = FALSE)
# Start by creating a data frame `clarity_summary` that includes summarized data
# for each clarity group. Your summary data should include the mean price and the
# standard error of the price.
clarity_summary <- diamonds %>%
group_by(clarity) %>%
summarize(mean = mean(price), sd = sd(price), se = sd / sqrt(length(price)))
# Then draw the plot. The error bars should stretch from the mean-error to the
# mean+error.
ggplot(data = clarity_summary, mapping = aes(x = clarity, y = mean)) +
geom_bar(mapping = aes(fill = clarity), stat = "identity") +
geom_errorbar(mapping = aes(ymin = (mean - se), ymax = (mean + se)))
# Draw a "boxplot" (with `geom_boxplot`) for the diamond's price (y) by color (x)
ggplot(data = diamonds_sample) +
geom_boxplot(mapping = aes(x = color, y = price))
# This has a lot of outliers, making it harder to read. To fix this, draw the
# same plot but with a _logarithmic_ scale for the y axis.
ggplot(data = diamonds_sample) +
geom_boxplot(mapping = aes(x = color, y = price)) +
scale_y_log10()
# For another version, draw the same plot but with `violin` geometry instead of
# `boxplot` geometry!
# How does the logarithmic scale change the data presentation?
ggplot(data = diamonds_sample) +
geom_violin(mapping = aes(x = color, y = price)) +
scale_y_log10()
# Another interesting plot: draw a plot of the diamonds price (y) by carat (x),
# using a heatmap of 2d bins (geom_bin2d)
# What happens when you make the x and y channels scale logarithmically?
ggplot(data = diamonds) +
geom_bin2d(mapping = aes(x = carat, y = price)) +
scale_x_log10() +
scale_y_log10()
# Draw a bar chart with x-position and fill color BOTH mapped to cut
# For best results, SET the `width` of the geometry to be 1 (fill plot, no space
# between)
# TIP: You can save the plot to a variable for easier modifications
bar <- ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = cut), width = 1)
bar
# Draw the same chart, but with the coordinate system flipped
bar + coord_flip()
# Draw the same chart, but in a polar coordinate system. It's a Coxcomb chart!
bar + coord_polar()
# Install and load the `ggplot2` package
# You will also want to load `dplyr`
library("ggplot2")
library("dplyr")
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
diamonds_sample <- sample_n(diamonds, 1000)
nrow(diamonds_sample)
View(diamonds_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamonds_sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
shiny::runApp('~/info201-final')
runApp('~/info201-final')
library("dplyr")
library("tidyr")
library("ggplot2")
library("shiny")
runApp('~/info201-final')
library("dplyr")
library("tidyr")
library("ggplot2")
biofuel <- read.csv("data/biofuel.csv", stringsAsFactors = FALSE)
co2 <- read.csv("data/co2.csv", stringsAsFactors = FALSE)
setwd("~/info201-final")
runApp()
library("dplyr", lib.loc="~/R/win-library/3.5")
library("ggplot2", lib.loc="~/R/win-library/3.5")
library("knitr", lib.loc="~/R/win-library/3.5")
library("shiny", lib.loc="~/R/win-library/3.5")
library("styler", lib.loc="~/R/win-library/3.5")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
styler:::style_selection()
styler:::style_selection()
runApp()
runApp()
runApp()
styler:::style_selection()
runApp()
runApp()
runApp()
runApp()
my_ui <- fluidPage(
titlePanel("Energy Sources and CO2 in the United States"),
h5(strong("Our project is focused on the different production levels of energy sources in the United States.
These are used for energy in everyday life such as the gas for transportation and heating systems.
Some of these energy sources include crude oil, natural gas, biofuel, and ethanol. While these serve
similar purposes, they are different in their impacts on the environment. There are two main factors
that one should consider with these different options: cost and impact. For example, one key
difference is that crude oil releases a significant amount of carbon dioxide into the atmosphere.
Compared to natural gas, that is about 30% more carbon dioxide produced. The other is that crude oil
is considered cheaper than natural gas, giving reason to why most commercial cars are designed to use crude
oil. These two fuel options are better than burning coal but are still causes of significant air pollution and
are nonrenewable. We will also be examining renewable energy sources like biofuel and ethanol.  ")),
navbarPage(
"Definitions",
page_one,
page_two,
page_three,
page_four,
page_five,
page_six,
page_seven
),
sidebarLayout(
sidebarPanel(
selectInput(
inputId = "choice_x", label = "X Varaible",
choices = c("BioFuel", "Crude_Oil", "Fuel_Ethanol", "Natural_Gas"),
selected = "Crude_Oil"
),
selectInput(
inputId = "choice_y", label = "Y Variable",
choices = c("BioFuel", "Crude_Oil", "Fuel_Ethanol", "Natural_Gas"),
selected = "BioFuel"
),
radioButtons(inputId = "points_text", label = "Would you like to view points or see state names?",
choices = list("States" = 1, "Points" = 2),
selected = 1)
),
mainPanel(
plotOutput(outputId = "table2")
)
)
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
correct_colnames_numeric$Fuel_Ethanol
correct_colnames_numeric$test
correct_colnames_numeric$(test)
correct_colnames_numeric[[test]]
correct_colnames_numeric[[test]]
test <- "Fuel_Ethanol"
correct_colnames_numeric[[test]]
correct_colnames_numeric$Fuel_Ethanol
